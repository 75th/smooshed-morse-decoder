{"version":3,"sources":["morse.js"],"names":["morse","s","tab","A","a","B","b","C","c","D","d","E","e","F","f","G","g","H","h","I","i","J","j","K","k","L","l","M","m","N","n","O","o","P","p","Q","q","R","r","S","T","t","U","u","V","v","W","w","X","x","Y","y","Z","z","0",",","1",".","2","?","3",";","4",":","5","'","6","-","7","/","8","(","9",")","_","+","output","length","char","slice","_callee","filenames","regeneratorRuntime","wrap","_context","prev","next","Promise","all","map","filename","fetch","concat","then","response","text","results","window","dispatchEvent","CustomEvent","detail","join","stop","init","getWordListFromFiles","addEventListener","wordList","words","initializeWordList","split","transformations","Transformation","reverse","Puzzle","word","trans","description","transform","addTransformationsToWordList","_classCallCheck","this","ciphertext","String","prototype"],"mappings":"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","sourcesContent":["'use strict';\n\nfunction morse(s) {\n\tconst tab = { // Courtesy of http://svn.python.org/projects/python/trunk/Demo/scripts/morse.py\n    'A': '.-',              'a': '.-',\n    'B': '-...',            'b': '-...',\n    'C': '-.-.',            'c': '-.-.',\n    'D': '-..',             'd': '-..',\n    'E': '.',               'e': '.',\n    'F': '..-.',            'f': '..-.',\n    'G': '--.',             'g': '--.',\n    'H': '....',            'h': '....',\n    'I': '..',              'i': '..',\n    'J': '.---',            'j': '.---',\n    'K': '-.-',             'k': '-.-',\n    'L': '.-..',            'l': '.-..',\n    'M': '--',              'm': '--',\n    'N': '-.',              'n': '-.',\n    'O': '---',             'o': '---',\n    'P': '.--.',            'p': '.--.',\n    'Q': '--.-',            'q': '--.-',\n    'R': '.-.',             'r': '.-.',\n    'S': '...',             's': '...',\n    'T': '-',               't': '-',\n    'U': '..-',             'u': '..-',\n    'V': '...-',            'v': '...-',\n    'W': '.--',             'w': '.--',\n    'X': '-..-',            'x': '-..-',\n    'Y': '-.--',            'y': '-.--',\n    'Z': '--..',            'z': '--..',\n    '0': '-----',           ',': '--..--',\n    '1': '.----',           '.': '.-.-.-',\n    '2': '..---',           '?': '..--..',\n    '3': '...--',           ';': '-.-.-.',\n    '4': '....-',           ':': '---...',\n    '5': '.....',           \"'\": '.----.',\n    '6': '-....',           '-': '-....-',\n    '7': '--...',           '/': '-..-.',\n    '8': '---..',           '(': '-.--.-',\n    '9': '----.',           ')': '-.--.-',\n                            '_': '..--.-',\n    '+': '.-.-.' // Courtesy of http://foldoc.org/Morse+code\n  }\n\n  var output = '';\n  for (let i = 0; i < s.length; i++) {\n    let char = s.slice(i, i + 1);\n    if (char in tab) {\n      output = output + tab[s[i]];\n    }\n\n    if (char === ' ') {\n      output = output + ' ';\n    }\n  }\n  return output;\n}\n\n/**\n * Port of Python `string.find()`.\n */\nfunction find(s, sub, start = 0, end = undefined) {\n  return s.slice(start, end).search(sub) + start;\n}\n\n/**\n * Find all the indices at which a substring begins inside a string,\n * including overlapping ones.\n */\nfunction findAll(s, sub, result = [], start = 0) {\n  var newLocation = find(s, sub, start);\n  if (newLocation === -1) {\n    return result;\n  }\n\n  result.push(newLocation);\n  result = findAll(s, sub, result, newLocation + 1);\n  return result;\n}\n\nfunction initializeWordList(words) {\n  const wordList = {}\n  const length = words.length;\n\n  for (let i = 0; i < length; i++) {\n    wordList[words[i]] = {};\n  }\n\n  return wordList;\n}\n\nfunction addTransformationsToWordList(wordList, transformations) {\n  const length = wordList.length;\n\n  for (let word in wordList) {\n    for (let trans in transformations) {\n      wordList[word]['transformations'][trans.description] = {\n        morse: trans.transform(word)\n      };\n    }\n  }\n}\n\nfunction addIndicesToWordList(wordList, puzzle) {\n  for (let word in wordList) {\n    for (let transformation in wordList[word]['transformations']) {\n      wordList[word]['transformations'][transformation]['indices'] =\n        findAll(puzzle, wordList[word]['transformations'][transformation]['morse'])\n      ;\n    }\n  }\n}\n\nfunction deleteAbsentWordsFromWordList(wordList) {\n  for (let word in wordList) {\n    var deleteWord = true;\n\n    for (let transformation in wordList[word]['transformations']) {\n      if (wordList[word]['transformations'][transformation]['indices'] !== []) {\n        deleteWord = false;\n      }\n    }\n\n    if (deleteWord) {\n      delete wordList[word];\n    }\n  }\n}\n\nfunction indicesTreeFromWordList(wordList) {\n  const indicesTree = {};\n  for (let word in wordList) {\n    let data = wordList[word];\n\n    for (let trans in data['transformations']) {\n      if (!(trans in indicesTree)) {\n        indicesTree[trans] = {};\n      }\n\n      for (let index in data['transformations'][trans]['indices']) {\n        if (!(index in indicesTree[trans])) {\n          indicesTree[trans][index] = [];\n        }\n\n        const length = wordList[word]['transformations'][trans]['morse'].length;\n        indicesTree[trans][index].push({\n          word: word,\n          length: length,\n          end: index + length\n        });\n      }\n    }\n  }\n  return indicesTree;\n}\n\nfunction reverseIndicesTreeFromIndicesTree(indicesTree, puzzle) {\n  const reverseIndicesTree = {};\n  const length = puzzle.length;\n  for (let index in indicesTree) {\n    let words = indicesTree[index];\n    for (let word in words) {\n      let revIndex = length - word['end'];\n      if(!(revIndex in reverseIndicesTree)) {\n        reverseIndicesTree[revIndex] = [];\n      }\n      reverseIndicesTree[revIndex].push({\n        word: word['word'],\n        length: word['length'],\n        end: length - index\n      });\n    }\n  }\n  return reverseIndicesTree;\n}\n\nfunction nextWordsFromWordList(wordList, transformation, startingIndex = 0, allowGaps = true) {\n  const nextWordCandidates = [];\n  for (let word in wordList) {\n    for (let index in wordList[word].transformations[transformation]['indices']) {\n      if (index < startingIndex) {\n        continue;\n      }\n      nextWordCandidates.push({\n        word: word,\n        index: index,\n        length: wordList[word].transformations['transformation'].morse.length\n      });\n    }\n  }\n  nextWordCandidates.sort((a, b) => {\n    var comparison = a.index - b.index;\n\n    if (comparison !== 0) {\n      return comparison;\n    }\n\n    return a.length - b.length;\n  });\n\n  if (nextWordCandidates.length === 0) {\n    return null;\n  }\n\n  const nextWords = [ nextWordCandidates[0] ];\n\n  for (let i = 1; i < nextWordCandidates.length - 1; i++) {\n    if (nextWordCandidates[i].index < nextWords[0].index + nextWords[0].length) {\n      nextWords.push(nextWordCandidates[i]);\n    }\n  }\n\n  return nextWords;\n}\n\nfunction nextWordsFromIndicesTree(indicesTree, transformation, puzzle, startingIndex = 0) {\n  const nextWords = [];\n  const puzzleLength = puzzle.length;\n\n  while (!(startingIndex in indicesTree[transformation])) {\n    startingIndex++;\n    if (startingIndex >= puzzleLength) {\n      return null;\n    }\n  }\n\n  for (let word in indicesTree[transformation][startingIndex]) {\n    let rword = word;\n    rword.index = startingIndex;\n    nextWords.append(rword);\n  }\n\n  return nextWords;\n}\n\nfunction allCombinationsFromWordList(wordList, transformation, resultTree = null) {\n  if(resultTree === null) {\n    resultTree = nextWordsFromWordList(wordList, transformation);\n  }\n\n  for (let word in resultTree) {\n    let next = nextWordsFromWordList(wordList, transformation, word.index + word.length);\n\n    if(next !== null) {\n      word.next = allCombinationsFromWordList(wordList, transformation, next);\n    } else {\n      word.next = next;\n    }\n  }\n\n  return resultTree;\n}\n\nfunction allCombinationsFromIndicesTree(indicesTree, transformation, puzzle, resultTree = null) {\n  if(resultTree === null) {\n    resultTree = nextWordsFromIndicesTree(indicesTree, transformation, puzzle)\n  }\n\n  for (let word in resultTree) {\n    let next = nextWordsFromIndicesTree(indicesTree, transformation, puzzle, word.index + word.length);\n\n    if(next !== null) {\n      word.next = allCombinationsFromIndicesTree(indicesTree, transformation, puzzle, next);\n    } else {\n      word.next = next;\n    }\n  }\n\n  return resultTree;\n}\n\nfunction flattenCombinations(resultTree, currentCombo = [], allCombos = []) {\n  if(resultTree === null) {\n    allCombos.push(currentCombo);\n    return;\n  }\n\n  for (let word in resultTree) {\n    let newCurrentCombo = currentCombo.slice();\n    newCurrentCombo.push({\n      word: word.word,\n      index: word.index,\n      length: word.length\n    });\n    flattenCombinations(word.next, newCurrentCombo, allCombos);\n  }\n  return allCombos;\n}\n\nasync function getWordListFromFiles(filenames ) {\n  Promise.all(\n    filenames.map(\n      filename => {\n        return fetch(`./words/${filename}.txt`)\n          .then(response => response.text())\n        ;\n      }\n    )\n  ).then(results => {\n    window.dispatchEvent(\n      new CustomEvent('wordlistready', {\n        detail: results.join(\"\\n\")\n      })\n    );\n  });\n}\n\nwindow.addEventListener('wordlistready', start);\n\n/*\nfunction loadResults() {\n  const names = [];\n  const results = [];\n\n  ['Dash at end', 'Dot at end'].forEach(ending => {\n    ['forward letters', 'backward letters'].forEach(letters => {\n      ['forward words', 'backward words'].forEach(words => {\n        ['forward morse', 'backward morse'].forEach(morse => {\n          const nameParts = [ending, letters, words, morse];\n          names.push(nameParts.join(', '));\n        });\n      });\n    });\n  });\n\n  names.forEach(async name => {\n    const result = getFile(name);\n    result.name = name;\n    results.push(result);\n  });\n\n  return results;\n}\n*/\nfunction getInitialPossibilities(result) {\n  var possibilities = [];\n\n  result['0'].forEach(wordData => {\n    possibilities.push({\n      sentenceSoFar: wordData.word,\n      nextIndex: wordData.end,\n      resultName: result.name\n    });\n  });\n\n  return possibilities;\n}\n\nfunction getNextPossibilities(possibility, result) {\n  const nextPossibilities = [];\n\n  result[possibility.nextIndex].forEach(wordData => {\n    nextPossibilities.push({\n      sentenceSoFar: possibility.sentenceSoFar + ' ' + wordData.word,\n      nextIndex: wordData.end,\n      resultName: result.name\n    });\n  });\n\n  return nextPossibilities;\n}\n\nfunction renderPossibility(possibility, resultName) {\n  var el = document.createElement('li');\n  el.setAttribute('data-result-name', resultName);\n  el.setAttribute('data-sentence-so-far', possibility.sentenceSoFar);\n  el.setAttribute('data-next-index', possibility.nextIndex);\n  el.innerHTML = `<button class=\"eliminate\" aria-label=\"Eliminate possibility\">×</button> ${possibility.sentenceSoFar}</button>`;\n  return el;\n}\n\nfunction init() {\n  getWordListFromFiles(['1', 'custom']);\n}\n\nclass Transformation {\n  constructor(transform, description) {\n    this.transform = transform;\n    this.description = description;\n  }\n}\n\nclass Puzzle {\n  constructor(ciphertext, description) {\n    this.ciphertext = ciphertext;\n    this.description = description;\n  }\n}\n\nif(!String.prototype.reverse) {\n  String.prototype.reverse = function() {\n    return this.split('').reverse().join('');\n  }\n}\n\nfunction start(e) {\n  const wordArray = e.detail.split(\"\\n\");\n  const wordList = initializeWordList(wordArray);\n\n  const transformations = [\n    new Transformation(x => morse(x), 'forward plaintext, forward morse'),\n    new Transformation(x => morse(x).reverse(), 'forward plaintext, backward morse'),\n    new Transformation(x => morse(x.reverse()), 'backward plaintext, forward morse'),\n    new Transformation(x => morse(x.reverse()).reverse(), 'backward plaintext, backward morse')\n  ];\n\n  const puzzles = [\n    new Puzzle('..-.---.-..-...--..--.-.--...--.-..-.-.---...--..-.--.-...--.-.---..-..--..-', 'Dash at end'),\n    new Puzzle('..-.---.-..-...--..--.-.--...--.-..-.-.---...--..-.--.-...--.-.---..-..--...', 'Dot at end')\n  ]\n\n  addTransformationsToWordList(wordList, transformations);\n\n  /*\n  const results = loadResults();\n\n  results.forEach(result => {\n    const section = document.createElement('section');\n    section.setAttribute('data-result-name', result.name);\n    section.innerHTML = `<h2>${result.name}</h2><ul></ul>`;\n    const list = section.querySelector('ul');\n    var possibilities = getInitialPossibilities(result);\n    var nextPossibilities = [];\n    possibilities.forEach(possibility => {\n      nextPossibilities = nextPossibilities + getNextPossibilities(possibility, result);\n    });\n\n    nextPossibilities.forEach(function(possibility) {\n      list.appendChild(renderPossibility(possibility, result.name));\n    });\n\n    console.log(section);\n\n    document.querySelector('.possibilities').appendChild(section);\n  });\n\n  */\n}\n\n(() => {\n  init();\n})();"]}