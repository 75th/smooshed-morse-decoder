{"version":3,"sources":["morse.js"],"names":["morse","plaintext","code","A","a","B","b","C","c","D","d","E","e","F","f","G","g","H","h","I","i","J","j","K","k","L","l","M","m","N","n","O","o","P","p","Q","q","R","r","S","s","T","t","U","u","V","v","W","w","X","x","Y","y","Z","z","0",",","1",".","2","?","3",";","4",":","5","'","6","-","7","/","8","(","9",")","_","+","output","length","character","slice","escapeRegExp","string","replace","find","sub","start","arguments","undefined","end","search","findAll","result","newLocation","push","_callee","filenames","regeneratorRuntime","wrap","_context","prev","next","Promise","all","map","filename","fetch","concat","then","response","text","results","window","dispatchEvent","CustomEvent","detail","join","stop","init","getWordListFromFiles","addEventListener","wordList","words","initializeWordList","split","transformations","Transformation","reverse","puzzles","Puzzle","console","log","word","transKey","trans","description","transform","addTransformationsToWordList","transformation","indices","ciphertext","addIndicesToWordList","_classCallCheck","this","String","prototype"],"mappings":"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","sourcesContent":["'use strict';\n\n/**\n * Returns the morse code equivalent of a text string.\n */\nfunction morse(plaintext) {\n\tconst code = { // Courtesy of http://svn.python.org/projects/python/trunk/Demo/scripts/morse.py\n    'A': '.-',              'a': '.-',\n    'B': '-...',            'b': '-...',\n    'C': '-.-.',            'c': '-.-.',\n    'D': '-..',             'd': '-..',\n    'E': '.',               'e': '.',\n    'F': '..-.',            'f': '..-.',\n    'G': '--.',             'g': '--.',\n    'H': '....',            'h': '....',\n    'I': '..',              'i': '..',\n    'J': '.---',            'j': '.---',\n    'K': '-.-',             'k': '-.-',\n    'L': '.-..',            'l': '.-..',\n    'M': '--',              'm': '--',\n    'N': '-.',              'n': '-.',\n    'O': '---',             'o': '---',\n    'P': '.--.',            'p': '.--.',\n    'Q': '--.-',            'q': '--.-',\n    'R': '.-.',             'r': '.-.',\n    'S': '...',             's': '...',\n    'T': '-',               't': '-',\n    'U': '..-',             'u': '..-',\n    'V': '...-',            'v': '...-',\n    'W': '.--',             'w': '.--',\n    'X': '-..-',            'x': '-..-',\n    'Y': '-.--',            'y': '-.--',\n    'Z': '--..',            'z': '--..',\n    '0': '-----',           ',': '--..--',\n    '1': '.----',           '.': '.-.-.-',\n    '2': '..---',           '?': '..--..',\n    '3': '...--',           ';': '-.-.-.',\n    '4': '....-',           ':': '---...',\n    '5': '.....',           \"'\": '.----.',\n    '6': '-....',           '-': '-....-',\n    '7': '--...',           '/': '-..-.',\n    '8': '---..',           '(': '-.--.-',\n    '9': '----.',           ')': '-.--.-',\n                            '_': '..--.-',\n    '+': '.-.-.' // Courtesy of http://foldoc.org/Morse+code\n  }\n\n  var output = '';\n  for (let i = 0; i < plaintext.length; i++) {\n    let character = plaintext.slice(i, i + 1);\n    if (character in code) {\n      output = output + code[character];\n    }\n\n    if (character === ' ') {\n      output = output + ' ';\n    }\n  }\n  return output;\n}\n\nfunction escapeRegExp(string) { // Courtesy of https://stackoverflow.com/questions/3446170/escape-string-for-use-in-javascript-regex\n  return string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'); // $& means the whole matched string\n}\n\n/**\n * Port of Python `string.find()`.\n */\nfunction find(s, sub, start = 0, end = undefined) {\n  if (!s || !sub) {\n    return -1;\n  }\n\n  return s.slice(start, end).search(escapeRegExp(sub));\n}\n\n/**\n * Find all the indices at which a substring begins inside a string,\n * including overlapping ones.\n */\nfunction findAll(s, sub, result = [], start = 0) {\n  var newLocation = find(s, sub, start);\n  if (newLocation === -1) {\n    return result;\n  }\n\n  result.push(newLocation + start);\n  result = findAll(s, sub, result, newLocation + start + 1);\n  return result;\n}\n\nfunction initializeWordList(words) {\n  const wordList = {}\n  const length = words.length;\n\n  for (let i = 0; i < length; i++) {\n    wordList[words[i]] = {};\n  }\n\n  return wordList;\n}\n\nfunction addTransformationsToWordList(wordList, transformations) {\n  const length = wordList.length;\n\n  for (let word in wordList) {\n    wordList[word]['transformations'] = {};\n    for (let transKey in transformations) {\n      let trans = transformations[transKey];\n\n      wordList[word]['transformations'][trans.description] = {\n        morse: trans.transform(word)\n      };\n    }\n  }\n}\n\nfunction addIndicesToWordList(wordList, puzzles) {\n  for (let word in wordList) {\n    for (let transformation in wordList[word]['transformations']) {\n      wordList[word]['transformations'][transformation]['indices'] = [];\n      for (let i = 0; i < puzzles.length; i++) {\n        let indices = findAll(puzzles[i].ciphertext, wordList[word]['transformations'][transformation]['morse']);\n        wordList[word]['transformations'][transformation]['indices'].push(indices);\n      }\n    }\n  }\n}\n\nfunction deleteAbsentWordsFromWordList(wordList) {\n  for (let word in wordList) {\n    var deleteWord = true;\n\n    for (let transformation in wordList[word]['transformations']) {\n      if (wordList[word]['transformations'][transformation]['indices'] !== []) {\n        deleteWord = false;\n      }\n    }\n\n    if (deleteWord) {\n      delete wordList[word];\n    }\n  }\n}\n\nfunction indicesTreeFromWordList(wordList) {\n  const indicesTree = {};\n  for (let word in wordList) {\n    let data = wordList[word];\n\n    for (let trans in data['transformations']) {\n      if (!(trans in indicesTree)) {\n        indicesTree[trans] = {};\n      }\n\n      for (let index in data['transformations'][trans]['indices']) {\n        if (!(index in indicesTree[trans])) {\n          indicesTree[trans][index] = [];\n        }\n\n        const length = wordList[word]['transformations'][trans]['morse'].length;\n        indicesTree[trans][index].push({\n          word: word,\n          length: length,\n          end: index + length\n        });\n      }\n    }\n  }\n  return indicesTree;\n}\n\nfunction reverseIndicesTreeFromIndicesTree(indicesTree, puzzle) {\n  const reverseIndicesTree = {};\n  const length = puzzle.length;\n  for (let index in indicesTree) {\n    let words = indicesTree[index];\n    for (let word in words) {\n      let revIndex = length - word['end'];\n      if(!(revIndex in reverseIndicesTree)) {\n        reverseIndicesTree[revIndex] = [];\n      }\n      reverseIndicesTree[revIndex].push({\n        word: word['word'],\n        length: word['length'],\n        end: length - index\n      });\n    }\n  }\n  return reverseIndicesTree;\n}\n\nfunction nextWordsFromWordList(wordList, transformation, startingIndex = 0, allowGaps = true) {\n  const nextWordCandidates = [];\n  for (let word in wordList) {\n    for (let index in wordList[word].transformations[transformation]['indices']) {\n      if (index < startingIndex) {\n        continue;\n      }\n      nextWordCandidates.push({\n        word: word,\n        index: index,\n        length: wordList[word].transformations['transformation'].morse.length\n      });\n    }\n  }\n\n  nextWordCandidates.sort((a, b) => {\n    var comparison = a.index - b.index;\n\n    if (comparison !== 0) {\n      return comparison;\n    }\n\n    return a.length - b.length;\n  });\n\n  if (nextWordCandidates.length === 0) {\n    return null;\n  }\n\n  const nextWords = [ nextWordCandidates[0] ];\n\n  for (let i = 1; i < nextWordCandidates.length - 1; i++) {\n    if (nextWordCandidates[i].index < nextWords[0].index + nextWords[0].length) {\n      nextWords.push(nextWordCandidates[i]);\n    }\n  }\n\n  return nextWords;\n}\n\nfunction nextWordsFromIndicesTree(indicesTree, transformation, puzzle, startingIndex = 0) {\n  const nextWords = [];\n  const puzzleLength = puzzle.length;\n\n  while (!(startingIndex in indicesTree[transformation])) {\n    startingIndex++;\n    if (startingIndex >= puzzleLength) {\n      return null;\n    }\n  }\n\n  for (let word in indicesTree[transformation][startingIndex]) {\n    let rword = word;\n    rword.index = startingIndex;\n    nextWords.append(rword);\n  }\n\n  return nextWords;\n}\n\nfunction allCombinationsFromWordList(wordList, transformation, resultTree = null) {\n  if(resultTree === null) {\n    resultTree = nextWordsFromWordList(wordList, transformation);\n  }\n\n  for (let word in resultTree) {\n    let next = nextWordsFromWordList(wordList, transformation, word.index + word.length);\n\n    if(next !== null) {\n      word.next = allCombinationsFromWordList(wordList, transformation, next);\n    } else {\n      word.next = next;\n    }\n  }\n\n  return resultTree;\n}\n\nfunction allCombinationsFromIndicesTree(indicesTree, transformation, puzzle, resultTree = null) {\n  if(resultTree === null) {\n    resultTree = nextWordsFromIndicesTree(indicesTree, transformation, puzzle)\n  }\n\n  for (let word in resultTree) {\n    let next = nextWordsFromIndicesTree(indicesTree, transformation, puzzle, word.index + word.length);\n\n    if(next !== null) {\n      word.next = allCombinationsFromIndicesTree(indicesTree, transformation, puzzle, next);\n    } else {\n      word.next = next;\n    }\n  }\n\n  return resultTree;\n}\n\nfunction flattenCombinations(resultTree, currentCombo = [], allCombos = []) {\n  if(resultTree === null) {\n    allCombos.push(currentCombo);\n    return;\n  }\n\n  for (let word in resultTree) {\n    let newCurrentCombo = currentCombo.slice();\n    newCurrentCombo.push({\n      word: word.word,\n      index: word.index,\n      length: word.length\n    });\n    flattenCombinations(word.next, newCurrentCombo, allCombos);\n  }\n  return allCombos;\n}\n\nasync function getWordListFromFiles(filenames) {\n  Promise.all(\n    filenames.map(\n      filename => {\n        return fetch(`./words/${filename}.txt`)\n          .then(response => response.text())\n        ;\n      }\n    )\n  ).then(results => {\n    window.dispatchEvent(\n      new CustomEvent('wordlistready', {\n        detail: results.join(\"\\n\")\n      })\n    );\n  });\n}\n\nwindow.addEventListener('wordlistready', start);\n\n/*\nfunction loadResults() {\n  const names = [];\n  const results = [];\n\n  ['Dash at end', 'Dot at end'].forEach(ending => {\n    ['forward letters', 'backward letters'].forEach(letters => {\n      ['forward words', 'backward words'].forEach(words => {\n        ['forward morse', 'backward morse'].forEach(morse => {\n          const nameParts = [ending, letters, words, morse];\n          names.push(nameParts.join(', '));\n        });\n      });\n    });\n  });\n\n  names.forEach(async name => {\n    const result = getFile(name);\n    result.name = name;\n    results.push(result);\n  });\n\n  return results;\n}\n*/\nfunction getInitialPossibilities(result) {\n  var possibilities = [];\n\n  result['0'].forEach(wordData => {\n    possibilities.push({\n      sentenceSoFar: wordData.word,\n      nextIndex: wordData.end,\n      resultName: result.name\n    });\n  });\n\n  return possibilities;\n}\n\nfunction getNextPossibilities(possibility, result) {\n  const nextPossibilities = [];\n\n  result[possibility.nextIndex].forEach(wordData => {\n    nextPossibilities.push({\n      sentenceSoFar: possibility.sentenceSoFar + ' ' + wordData.word,\n      nextIndex: wordData.end,\n      resultName: result.name\n    });\n  });\n\n  return nextPossibilities;\n}\n\nfunction renderPossibility(possibility, resultName) {\n  var el = document.createElement('li');\n  el.setAttribute('data-result-name', resultName);\n  el.setAttribute('data-sentence-so-far', possibility.sentenceSoFar);\n  el.setAttribute('data-next-index', possibility.nextIndex);\n  el.innerHTML = `<button class=\"eliminate\" aria-label=\"Eliminate possibility\">×</button> ${possibility.sentenceSoFar}</button>`;\n  return el;\n}\n\nfunction init() {\n  getWordListFromFiles(['1', 'custom']);\n}\n\nclass Transformation {\n  constructor(transform, description) {\n    this.transform = transform;\n    this.description = description;\n  }\n}\n\nclass Puzzle {\n  constructor(ciphertext, description) {\n    this.ciphertext = ciphertext;\n    this.description = description;\n  }\n}\n\nif(!String.prototype.reverse) {\n  String.prototype.reverse = function() {\n    return this.split('').reverse().join('');\n  }\n}\n\nfunction logWordListSamples(wordList, numberOfSamples = 20) {\n  const wordArray = Object.keys(wordList);\n  const length = wordArray.length;\n  const fraction = Math.floor(length / numberOfSamples);\n\n  for (let sampleIndex = 0; sampleIndex <= numberOfSamples; sampleIndex++) {\n    let wordIndex = sampleIndex * fraction;\n    console.log(wordArray[wordIndex], wordList[wordArray[wordIndex]]);\n  }\n}\n\nfunction start(e) {\n  const wordArray = e.detail.split(\"\\n\");\n  const wordList = initializeWordList(wordArray);\n\n  const transformations = [\n    new Transformation(x => morse(x), 'forward plaintext, forward morse'),\n    new Transformation(x => morse(x).reverse(), 'forward plaintext, backward morse'),\n    new Transformation(x => morse(x.reverse()), 'backward plaintext, forward morse'),\n    new Transformation(x => morse(x.reverse()).reverse(), 'backward plaintext, backward morse')\n  ];\n\n  const puzzles = [\n    new Puzzle('..-.---.-..-...--..--.-.--...--.-..-.-.---...--..-.--.-...--.-.---..-..--..-', 'dash at end'),\n    new Puzzle('..-.---.-..-...--..--.-.--...--.-..-.-.---...--..-.--.-...--.-.---..-..--...', 'dot at end')\n  ];\n\n  console.log('addTransformationsToWordList');\n  addTransformationsToWordList(wordList, transformations);\n\n  console.log('addIndicesToWordList');\n  addIndicesToWordList(wordList, puzzles);\n\n  // logWordListSamples(wordList);\n\n\n\n\n\n  /*\n  const results = loadResults();\n\n  results.forEach(result => {\n    const section = document.createElement('section');\n    section.setAttribute('data-result-name', result.name);\n    section.innerHTML = `<h2>${result.name}</h2><ul></ul>`;\n    const list = section.querySelector('ul');\n    var possibilities = getInitialPossibilities(result);\n    var nextPossibilities = [];\n    possibilities.forEach(possibility => {\n      nextPossibilities = nextPossibilities + getNextPossibilities(possibility, result);\n    });\n\n    nextPossibilities.forEach(function(possibility) {\n      list.appendChild(renderPossibility(possibility, result.name));\n    });\n\n    console.log(section);\n\n    document.querySelector('.possibilities').appendChild(section);\n  });\n\n  */\n}\n\n(() => {\n  init();\n})();\n"]}